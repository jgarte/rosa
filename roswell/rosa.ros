#!/bin/sh
#|-*- mode:lisp -*-|#
#| Rosa command line front-end
exec ros -Q -- $0 "$@"
|#
(defpackage :rosa.command
  (:use :cl))

(ql:quickload '(:cl-yaml
                :inquisitor
                :jonathan
                :rosa)
              :silent t)

(in-package :rosa.command)


(defun print-usage ()
  (format *error-output* "Rosa - text labeling language CLI
usage: rosa list [OPTIONS] [FILE]
       rosa pick [OPTIONS] LABEL [FILE]
       rosa scan [OPTIONS] [FILE]

DESCRIPTION
    rosa extract key-value structure from input. key as 'label'
    and value as 'body'.

    if not supplied `file`, rosa reads from standard input.

COMMANDS
    rosa list [FILE]
        list all labels from input. by default, formatted as
        line-based plain text.

    rosa pick LABEL [FILE]
        pick up the value(s) corresponding to the label, from
        input. by default, rosa returns only first body of
        all appearance.

    rosa scan [FILE]
        parse and print entire key-value data from input.

FORMATTING OPTIONS
    output formatting type. by default, output formatted as
    S-expression.

      -s
          format output as S-expression.
      -j
          format output as JSON.
      -y
          format output as YAML.

PICKING UP OPTIONS
    available with pick command.

      -a
          if supplied, all bodies are printed as formatting
          type.

      -n NUM
          specify number of bodies picking up from head.
          default, no supplied, NUM set as 1.

"))

(defstruct option
  command format-type pick-label pick-all pick-nth pathname)

(defun error-and-exit (s)
  (format t "~a~%~%" s)
  (uiop:quit 1))

(defun parse-argv (argv)
  (let ((option (make-option)))
    (flet ((optionp (a)
             (char= (aref a 0) #\-))
           (find-format-type (a)
             (setf (option-format-type option)
                   (cond ((string= a "-s") :sexp)
                         ((string= a "-j") :json)
                         ((string= a "-y") :yaml)))))
      (let ((command (first argv)))
        (if (or (not command)
                (not (member command '("list" "pick" "scan") :test #'string=)))
            (error-and-exit (format nil "unknown command: ~s" command))
            (setf (option-command option)
                  (intern (string-upcase command) :keyword))))
      (loop
         :for n :from 1 :below (length argv)
         :with command := (option-command option)
         :for a string := (nth n argv)
         :do (if (optionp a)
                 (cond ((member a '("-s" "-j" "-y") :test #'string=)
                        (when (not (option-format-type option))
                          (find-format-type a)))
                       ((and (eq command :pick)
                             (string= a "-a"))
                        (setf (option-pick-all option) t))
                       ((and (eq command :pick)
                             (string= a "-n"))
                        (incf n)
                        (handler-case
                            (setf (option-pick-nth option) (parse-integer (nth n argv)))
                          (condition (c)
                            (declare (ignore c))
                            (error-and-exit (format nil "~s is not positive integer"
                                                    (nth n argv))))))
                       (t (error-and-exit (format nil "unknown option: ~s" a))))
                 (cond ((and (eq command :pick)
                             (not (option-pick-label option)))
                        (setf (option-pick-label option) (intern a :keyword)))
                       (t (if (not (option-pathname option))
                              (setf (option-pathname option) (pathname a))
                              (error-and-exit "too many arguments"))))))
      option)))

(defmacro with-input ((var pathname) &body body)
  `(if ,pathname
       (if (probe-file ,pathname)
           (with-open-file (,var ,pathname
                            :direction :input
                            :external-format (inq:make-external-format
                                              :utf8
                                              (inq:detect-end-of-line (pathname ,pathname))))
             ,@body)
           (error-and-exit (format nil "no such file: ~s" ,pathname)))
       (let ((,var *standard-input*))
         ,@body)))

(defun list-labels (option)
  (with-input (in (option-pathname option))
    (let ((labels (rosa:index in)))
      (case (option-format-type option)
        (:sexp (format t "~s~%" labels))
        (:json (format t "~a~%"
                       (jojo:to-json (loop
                                        :for l :in labels
                                        :collect (symbol-name l)))))
        (:yaml (format t "~a~%"
                       (yaml:emit-to-string
                        (loop
                           :for l :in labels
                           :collect (symbol-name l)))))
        (t (loop :for l :in labels :do (format t "~a~%" l)))))))

(defun pick-bodies (option)
  (with-input (in (option-pathname option))
    (flet ((print-body (body format-type)
             (case format-type
               (:sexp (format t "~s~%" body))
               (:json (format t "~a~%" (jojo:to-json body)))
               (:yaml (format t "~a~%" (yaml:emit-to-string body)))
               (t (format t "~a~%" body))))
           (expected-body (bodies)
             (let ((pick-nth (option-pick-nth option)))
               (handler-case
                   (cond ((option-pick-all option) bodies)
                         (pick-nth (aref bodies pick-nth))
                         (t (aref bodies 0)))
                 (condition (c)
                   (error-and-exit (format nil "~a" c)))))))
      (let* ((expected (expected-body (rosa:pick in (option-pick-label option)))))
        (if (stringp expected)
            (print-body expected nil)
            (print-body expected
                        (or (option-format-type option) :sexp)))))))

(defun scan-all (option)
  (with-input (in (option-pathname option))
    (let ((format-type (or (option-format-type option) :sexp)))
      (flet ((string-keyed-data ()
               (let ((newhash (make-hash-table :test #'equal)))
                 (maphash (lambda (k v)
                            (setf (gethash (symbol-name k) newhash) v))
                          (rosa:peruse in))
                 newhash)))
        (case format-type
          (:sexp (format t "~s~%" (rosa:peruse-as-plist in)))
          (:json (format t "~a~%" (jojo:to-json (rosa:peruse-as-plist in))))
          (:yaml (format t "~a~%" (yaml:emit-to-string (string-keyed-data)))))))))

(defun main (&rest argv)
  (if (< (length argv) 1)
      (progn
        (print-usage)
        (uiop:quit))
      (let ((option (parse-argv argv)))
        (case (option-command option)
          (:list (list-labels option))
          (:pick (pick-bodies option))
          (:scan (scan-all option))))))
;;; vim: set ft=lisp lisp:
